---
description: Test-Driven Development workflow and testing standards
globs: ["**/*.py", "tests/**/*"]
alwaysApply: true
---

# Test-Driven Development (TDD)

## TDD Workflow

YClade follows strict TDD practices. Every feature starts with a failing test.

### The TDD Cycle

1. **Write test first** - Create a test in `tests/` that describes the expected behavior
2. **Run test, confirm it fails** - Verify the test fails for the right reason
3. **Implement minimum code** - Write just enough code to pass the test
4. **Refactor if needed** - Clean up while keeping tests green
5. **Commit** - Make a focused commit with descriptive message

```bash
# Run tests during development
pytest tests/ -v

# Run specific test file
pytest tests/test_tree.py -v

# Run with coverage
pytest tests/ --cov=src/yclade --cov-report=term-missing
```

## Test Organization

### Test File Structure

```
tests/
├── conftest.py         # Shared fixtures
├── fixtures/           # Test data files
├── test_tree.py        # Tests for tree.py
├── test_snps.py        # Tests for snps.py
├── test_vcf.py         # Tests for vcf.py
├── test_classifier.py  # Tests for classifier.py
└── test_integration.py # End-to-end tests
```

### Test Class Organization

Group related tests into classes:

```python
class TestNode:
    """Tests for Node dataclass."""

    def test_node_creation(self) -> None:
        """Test basic node creation."""
        ...

    def test_node_equality(self) -> None:
        """Nodes with same name are equal."""
        ...


class TestTree:
    """Tests for Tree class."""

    def test_tree_from_dict(self, sample_tree_dict: dict) -> None:
        """Test tree construction from dictionary."""
        ...
```

## Test Naming

Test names should clearly describe the behavior being tested:

```python
# CORRECT: Descriptive names
def test_tree_loads_yfull_json():
def test_node_depth_calculation():
def test_path_to_root_includes_all_ancestors():
def test_empty_tree_raises_value_error():

# WRONG: Vague names
def test_tree():
def test_it_works():
def test_stuff():
```

## Fixtures

### Shared Fixtures in conftest.py

Define reusable fixtures in `tests/conftest.py`:

```python
@pytest.fixture
def fixtures_dir() -> Path:
    """Return path to fixtures directory."""
    return Path(__file__).parent / "fixtures"


@pytest.fixture
def sample_tree_dict() -> dict:
    """Return a minimal tree structure for testing."""
    return {
        'ROOT (Y-Chromosome "Adam")': ["A00", "A0-T"],
        "A00": ["A00a", "A00b"],
        ...
    }
```

### Temporary Files

Use `tmp_path` fixture for temporary files:

```python
def test_tree_from_json(self, tmp_path: Path, sample_tree_dict: dict) -> None:
    """Test tree construction from JSON file."""
    json_path = tmp_path / "tree.json"
    with open(json_path, "w") as f:
        json.dump(sample_tree_dict, f)

    tree = Tree.from_json(json_path)
    assert tree.root.name == 'ROOT (Y-Chromosome "Adam")'
```

## Assertions

### Use Descriptive Assertions

```python
# CORRECT: Clear assertions
assert tree.root.name == 'ROOT (Y-Chromosome "Adam")'
assert len(tree) > 0
assert "R-L21" in tree
assert result.confidence > 0.9

# Also good: pytest.raises for exceptions
with pytest.raises(ValueError, match="Empty tree data"):
    Tree.from_dict({})

with pytest.raises(KeyError):
    tree.get("NOT_EXISTS")
```

## Test Markers

### Marking Slow Tests

```python
@pytest.mark.slow
def test_1000g_accuracy():
    """Validate against all 1000 Genomes males."""
    ...
```

### Marking Integration Tests

```python
@pytest.mark.integration
def test_classify_with_real_data():
    """Test classification with actual VCF files."""
    ...
```

Run excluding slow tests:

```bash
pytest tests/ -m "not slow"
```

## Test Coverage

- Aim for high coverage on core logic
- Focus on edge cases and error conditions
- Don't write tests just to increase coverage numbers

```bash
# Check coverage
pytest tests/ --cov=src/yclade --cov-report=term-missing

# Generate HTML report
pytest tests/ --cov=src/yclade --cov-report=html
```

## Writing Tests Before Implementation

When starting a new feature:

1. Create the test file if it doesn't exist
2. Write tests that describe expected behavior
3. Run tests to see them fail (confirms test is valid)
4. Implement the feature
5. Run tests to see them pass
6. Refactor if needed

```python
# Example: Writing tests before implementing path_to_root

def test_path_to_root(self, sample_tree_dict: dict) -> None:
    """Test path from node to root."""
    tree = Tree.from_dict(sample_tree_dict)

    path = tree.path_to_root("R-L21")
    assert path[0] == "R-L21"           # Starts with target
    assert path[-1] == 'ROOT ...'       # Ends with root
    assert "R1b" in path                # Includes ancestor
    assert "R" in path                  # Includes ancestor
```
