---
description: Error handling philosophy - fail hard, no fallbacks
globs: ["**/*.py"]
alwaysApply: true
---

# Error Handling Philosophy

## Core Principle: Fail Hard

**Never swallow errors. Never create fallbacks. Let exceptions bubble up with full context.**

When something fails, the failure should be visible and debuggable, not hidden behind a default value or generic fallback.

## CORRECT: Let Exceptions Propagate

```python
def load_tree(path: Path) -> Tree:
    """
    Load tree from JSON file.

    Raises:
        FileNotFoundError: If file doesn't exist
        json.JSONDecodeError: If file is not valid JSON
        ValueError: If JSON structure is invalid
    """
    with open(path) as f:
        data = json.load(f)
    return Tree.from_dict(data)
```

## WRONG: Swallowing Errors

```python
# NEVER DO THIS
def load_tree(path: Path) -> Tree | None:
    try:
        with open(path) as f:
            return Tree.from_dict(json.load(f))
    except Exception:
        return None  # This hides the actual problem!
```

## WRONG: Generic Fallbacks

```python
# NEVER DO THIS
def get_position(self, reference: str) -> int:
    try:
        return self._positions[reference]
    except KeyError:
        return 0  # Fallback hides the bug that reference was invalid
```

## Raising Meaningful Exceptions

### Include Context in Error Messages

```python
# CORRECT: Descriptive error message
if len(roots) != 1:
    raise ValueError(
        f"Expected 1 root node, found {len(roots)}: {[r.name for r in roots]}"
    )

# CORRECT: Include the invalid value
if reference not in ("grch37", "grch38", "t2t"):
    raise ValueError(f"Unknown reference: {reference}")

# WRONG: Generic message
raise ValueError("Invalid input")
```

### Use Appropriate Exception Types

- `ValueError` - Invalid argument values
- `KeyError` - Missing key in dict-like structures
- `FileNotFoundError` - Missing files
- `RuntimeError` - Invalid state or operation
- `TypeError` - Wrong type passed

```python
def get(self, name: str) -> Node:
    """
    Get node by haplogroup name.

    Raises:
        KeyError: If haplogroup not found
    """
    return self._nodes[name]  # Let KeyError propagate naturally


def _detect_y_chrom(self) -> None:
    """Detect Y chromosome naming convention in VCF."""
    contigs = set(self._vcf.header.contigs.keys())
    for name in self.Y_CHROMS:
        if name in contigs:
            self._y_chrom = name
            return

    raise ValueError(f"No Y chromosome found in VCF. Contigs: {contigs}")
```

## CLI Error Handling

The CLI is the **only place** where we catch and translate exceptions to exit codes:

```python
try:
    result = classifier.classify(vcf, sample)
    ...
except FileNotFoundError as e:
    click.echo(f"Error: File not found: {e}", err=True)
    sys.exit(10)
except ValueError as e:
    click.echo(f"Error: Invalid input: {e}", err=True)
    sys.exit(11)
except Exception as e:
    click.echo(f"Error: {e}", err=True)
    sys.exit(99)
```

## Exit Code Convention

| Code | Meaning |
|------|---------|
| 0 | Success (high confidence) |
| 1 | Classification failed (no haplogroup) |
| 2 | Low confidence (<0.95) |
| 10 | File not found |
| 11 | Invalid input |
| 99 | Unexpected error |

## Validation at Boundaries

Validate at system boundaries (user input, file input, external APIs), not within internal functions:

```python
# CLI validates input
@click.option(
    "--reference",
    type=click.Choice(["grch37", "grch38", "t2t"]),  # Validation at boundary
    default="grch38",
)

# Internal code can assume valid input
def get_position(self, reference: ReferenceGenome) -> int | None:
    if reference == "grch37":
        return self.position_grch37
    elif reference == "grch38":
        return self.position_grch38
    elif reference == "t2t":
        return self.position_t2t
    else:
        # This should never happen if boundaries are validated
        raise ValueError(f"Unknown reference: {reference}")
```

## Testing Error Conditions

Always test that errors are raised correctly:

```python
def test_tree_empty_raises(self) -> None:
    """Empty tree data raises ValueError."""
    with pytest.raises(ValueError, match="Empty tree data"):
        Tree.from_dict({})


def test_tree_get_missing_raises(self, sample_tree_dict: dict) -> None:
    """Getting missing node raises KeyError."""
    tree = Tree.from_dict(sample_tree_dict)

    with pytest.raises(KeyError):
        tree.get("NOT_EXISTS")
```
