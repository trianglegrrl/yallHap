---
description: Python best practices and coding standards for YClade
globs: ["**/*.py"]
alwaysApply: true
---

# Python Best Practices

## Python Version

- **Minimum Version**: Python 3.10+
- Use modern Python features: `match` statements, union types (`X | Y`), structural pattern matching

## Type Hints

Type hints are **required** on all public functions and methods. MyPy strict mode is enforced.

### Required Type Annotations

```python
# CORRECT: Full type annotations
def classify(
    vcf_path: Path | str,
    tree: Tree,
    reference: ReferenceGenome = "grch38",
) -> HaplogroupCall:
    """Classify haplogroup from VCF."""
    ...

# WRONG: Missing annotations
def classify(vcf_path, tree, reference="grch38"):
    ...
```

### Union Types (Modern Syntax)

```python
# CORRECT: Modern union syntax
def get_position(self, reference: str) -> int | None:
    ...

# WRONG: Old-style Optional
def get_position(self, reference: str) -> Optional[int]:
    ...
```

### Type Aliases

Define type aliases for complex types and literal unions:

```python
from typing import Literal

ReferenceGenome = Literal["grch37", "grch38", "t2t"]
```

## Docstrings (Google Style)

All public functions, classes, and modules require Google-style docstrings:

```python
def load_tree(path: Path) -> Tree:
    """
    Load phylogenetic tree from JSON file.

    Args:
        path: Path to YFull tree JSON file

    Returns:
        Populated Tree instance

    Raises:
        FileNotFoundError: If file doesn't exist
        json.JSONDecodeError: If file is not valid JSON
        ValueError: If JSON structure is invalid
    """
```

## Imports

### Import Order (enforced by ruff)

1. Standard library
2. Third-party packages
3. Local imports

```python
from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Iterator

import pandas as pd
import pysam

from yclade.snps import SNP, SNPDatabase
from yclade.tree import Tree
```

### Future Annotations

Always include `from __future__ import annotations` at the top of modules for forward reference support.

## Naming Conventions

- **Modules**: `snake_case.py`
- **Classes**: `PascalCase`
- **Functions/Methods**: `snake_case`
- **Constants**: `UPPER_SNAKE_CASE`
- **Private members**: `_leading_underscore`

## Path Handling

Always use `pathlib.Path`, never string concatenation:

```python
# CORRECT
from pathlib import Path

def load_file(path: Path | str) -> Data:
    path = Path(path)  # Normalize
    with open(path) as f:
        return parse(f)

# WRONG
def load_file(path):
    with open(path + "/data.json") as f:
        ...
```

## Collections

### List Comprehensions (preferred)

```python
# CORRECT: List comprehension
names = [node.name for node in nodes if node.depth > 0]

# AVOID: Manual loop for simple transformations
names = []
for node in nodes:
    if node.depth > 0:
        names.append(node.name)
```

### Default Mutable Arguments

Never use mutable defaults. Use `field(default_factory=...)`:

```python
# CORRECT
@dataclass
class Node:
    children: list[str] = field(default_factory=list)

# WRONG
@dataclass
class Node:
    children: list[str] = []  # Shared mutable!
```

## Properties

Use `@property` for computed attributes:

```python
@property
def total_called(self) -> int:
    """Total number of called variants."""
    return self.derived + self.ancestral

@property
def is_snp(self) -> bool:
    """Check if variant is a SNP (not indel)."""
    return len(self.ref) == 1 and all(len(a) == 1 for a in self.alt)
```
